<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üõ°Ô∏è Multi-Sensor Drone Tracking Dashboard</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: #333;
            min-height: 100vh;
        }
        .main-visuals {
            width: 100%;
            max-width: min(95vw, 1600px);
            box-sizing: border-box;
            margin: 20px auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
        }
        
        .header h1 {
            font-size: 2.5em;
            margin: 0;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .header p {
            font-size: 1.2em;
            margin: 10px 0;
            opacity: 0.9;
        }
        
        .controls {
            background: rgba(255,255,255,0.95);
            border-radius: 15px;
            margin-bottom: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
            width: 100%;
            max-width: min(95vw, 1600px);
            margin: 20px auto;
            padding:20px;
            box-sizing: border-box;
        }
        
        .time-controls {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 15px;
        }
        
        .time-controls label {
            font-weight: bold;
            color: #2c3e50;
            min-width: 100px;
        }

        .container {
            width: 100%;
            max-width: min(90vw, 1600px); 
            margin: 0 auto;
            padding: 0 16px;
            box-sizing: border-box;
        }

        
        .time-slider {
            flex: 1;
            height: 30px;
            background: linear-gradient(90deg, #3498db, #2ecc71);
            border-radius: 15px;
            outline: none;
            -webkit-appearance: none;
        }
        
        .time-slider::-webkit-slider-thumb {
            appearance: none;
            width: 30px;
            height: 30px;
            background: white;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            border: 3px solid #3498db;
        }
        
        .time-display {
            background: #34495e;
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-weight: bold;
            min-width: 200px;
            text-align: center;
        }
        
        .sensor-status {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }
        
        .sensor-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        
        .sensor-card h3 {
            margin: 0 0 10px 0;
            font-size: 1.1em;
        }
        
        .sensor-card .status {
            font-size: 0.9em;
            opacity: 0.9;
        }
        
        .full-width-container {
            width: 100%;
            margin-bottom: 20px;
        }

        .charts-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            width: 100%;
            box-sizing: border-box;
            margin-bottom: 20px;
        }
        
        .chart-panel {
            background: rgba(255,255,255,0.95);
            border-radius: 15px;
            padding: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
            height: 50vh;
            min-height: 300px;
            box-sizing: border-box;
            position: relative;
        }
        #altitudeChart,
        #errorChart {
            width: 100%;
            height: 100%;
        }
        
        .map-container {
            background: rgba(255,255,255,0.95);
            border-radius: 15px;
            padding: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
            margin-bottom: 20px;
            height: 60vh;
            min-height: 400px;
            width: 100%;
            box-sizing: border-box;
            position: relative;
        }
        #flightPathMap {
            width: 100%;
            height: 100%;
        }
        
        .performance-panel {
            background: rgba(255,255,255,0.95);
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
            width: 100%;
            max-width: min(95vw, 1600px);
            margin: 20px auto;
            padding: 20px;
            box-sizing: border-box;
        }
        
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .metric-card {
            background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);
            color: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }
        
        .metric-card.warning {
            background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
        }
        
        .metric-card.error {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
        }
        
        .metric-value {
            font-size: 1.5em;
            font-weight: bold;
            margin: 5px 0;
        }
        
        .metric-label {
            font-size: 0.9em;
            opacity: 0.9;
        }
        .page-container {
            padding: 0 16px;
        }

        @media (max-width: 1200px) {
            .charts-grid {
                grid-template-columns: 1fr;
            }
        }
        
        @media (max-width: 768px) {
            .time-controls {
                flex-direction: column;
                gap: 10px;
            }
            
            .sensor-status {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="page-container">
        <div class="header" style="position: relative;">                        
            <h1>üõ°Ô∏è Multi-Sensor Drone Tracking Dashboard</h1>
            <p>Real-time fusion analysis: Ground Truth vs Multi-Sensor Detection Systems</p>
            <button onclick="openModal()" style="position: absolute; top: 10px; right: 10px; padding: 10px 15px; border: none; background: #ffffffdd; color: #2c3e50; font-weight: bold; border-radius: 8px; cursor: pointer; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                ‚ùì Instructions
            </button>
        </div>

        <div class="controls">
            <div class="time-controls">
                <label for="timeSlider">Timeline:</label>
                <input type="range" id="timeSlider" class="time-slider" min="0" max="{{ total_frames - 1 }}" value="0">
                <div id="currentTime" class="time-display">Time: Loading...</div>
                <label for="sensorFilter">Select Sensor(s):</label>
                <div id="sensorFilter" style="display: flex; gap: 10px; flex-wrap: wrap;">
                    <label><input type="checkbox" value="ALL" checked> All</label>
                    <label><input type="checkbox" value="alvira" checked> ALVIRA</label>
                    <label><input type="checkbox" value="arcus" checked> ARCUS</label>
                    <label><input type="checkbox" value="diana" checked> DIANA</label>
                    <label><input type="checkbox" value="venus" checked> VENUS</label>
                </div>
            </div>
            
            <div class="sensor-status">
                <div class="sensor-card">
                    <h3>üéØ GROUND TRUTH</h3>
                    <div class="status">Active</div>
                </div>
                <div class="sensor-card">
                    <h3>üì° ALVIRA (2D Radar)</h3>
                    <div class="status" id="alviraStatus">Checking...</div>
                </div>
                <div class="sensor-card">
                    <h3>üåê ARCUS (3D Radar)</h3>
                    <div class="status" id="arcusStatus">Checking...</div>
                </div>
                <div class="sensor-card">
                    <h3>üìª DIANA (RF-DF)</h3>
                    <div class="status" id="dianaStatus">Checking...</div>
                </div>
                <div class="sensor-card">
                    <h3>üì° VENUS (RF-DF)</h3>
                    <div class="status" id="venusStatus">Checking...</div>
                </div>
            </div>
        </div>

        <div class="container" style="color: white; margin-top: 10px; margin-bottom: 20px;">
            <h3>üß≠ Timeline & Sensor Selection</h3>
            <p>
              Scrub through the drone's flight using the timeline slider. Use checkboxes to toggle specific sensors.
              Ground Truth acts as the benchmark trajectory, while each sensor system reports its own detections.
              Status cards summarize real-time performance ‚Äî whether a sensor is active, and if so, its current error or signal level.
            </p>
          </div>
          

        <div class="main-visuals">
            <div class="container">
            <div class="charts-grid">
                <div class="container chart-section">
                    <div class="chart-description">
                      <h3>üì∂ Altitude Tracking</h3>
                      <p>
                        This chart shows each sensor's reported altitude over time compared to the Ground Truth (black line).
                        Discontinuities or spikes may indicate lost tracking, sensor drift, or latency.
                        Use this chart to validate the reliability of vertical position detection.
                      </p>
                    </div>
                    <div class="chart-panel">
                      <div id="altitudeChart"></div>
                    </div>
                  </div>
                  
                  <div class="container chart-section">
                    <div class="chart-description">
                      <h3>üìâ Position Error Analysis</h3>
                      <p>
                        Displays how far off each sensor's reported position is from the Ground Truth, measured in meters.
                        Lower error indicates better tracking performance.
                        High error values may point to environmental interference or weak signal confidence.
                      </p>
                    </div>
                    <div class="chart-panel">
                      <div id="errorChart"></div>
                    </div>
                  </div>                  
            </div>
            <div class="container" style="color: white; margin-bottom: 10px;">
                <h3>üó∫Ô∏è Multi-Sensor Flight Path Map</h3>
                <p>
                  The map shows live tracking overlays from each sensor versus the Ground Truth flight path.
                  Black represents the known trajectory; other colors represent sensor-reported tracks.
                  Use this to compare spatial alignment and detect location offsets or tracking divergence.
                </p>
              </div>
              
            <div class="map-container">
                <div id="flightPathMap"></div>
            </div>
            </div>
        </div>

        <div class="container" style="color: white; margin-bottom: 10px;">
            <h3>üìä Real-Time Sensor Performance</h3>
            <p>
              These metrics summarize how well each sensor is performing in terms of detection rate and error.
              Cards are color-coded: <span style="color:#2ecc71;">green</span> for good, <span style="color:#f39c12;">yellow</span> for warning, and <span style="color:#e74c3c;">red</span> for critical.
              Values update every 5 seconds to reflect the latest results.
            </p>
          </div>
          
        

        <div class="performance-panel">
            <h2>üìä Real-Time Performance Metrics</h2>
            <div id="metricsGrid" class="metrics-grid">
                <div class="metric-card">
                    <div class="metric-value">Loading...</div>
                    <div class="metric-label">Initializing System</div>
                </div>
            </div>
        </div>
        <div class="container" style="color: white; margin-top: 20px;">
            <h3>üîç Sensor System Key</h3>
            <ul>
              <li><strong>GROUND TRUTH</strong>: GPS-based, serves as baseline truth.</li>
              <li><strong>ALVIRA</strong>: 2D radar ‚Äî tracks lateral position, no altitude.</li>
              <li><strong>ARCUS</strong>: 3D radar ‚Äî reports full XYZ coordinates.</li>
              <li><strong>DIANA</strong>: RF-DF (radio direction-finding), sensitive to signal quality.</li>
              <li><strong>VENUS</strong>: RF-DF operating on a different frequency band.</li>
            </ul>
          </div>
          
        <script>
            // Data from Flask
            const droneData = {{ drone_data_json | safe }};
            const timeSlider = document.getElementById('timeSlider');
            const currentTimeDisplay = document.getElementById('currentTime');
            
            // Sensor colors for consistent visualization
            const SENSOR_COLORS = {
                ground_truth: '#2c3e50',
                alvira: '#e74c3c',
                arcus: '#3498db',
                diana: '#f39c12',
                venus: '#9b59b6'
            };
            
            // Initialize all visualizations
            initializeAltitudeChart();
            initializeErrorChart();
            initializeFlightPathMap();
            window.addEventListener('resize', () => {
                Plotly.Plots.resize('flightPathMap');
                Plotly.Plots.resize('altitudeChart');
                Plotly.Plots.resize('errorChart');
                });

            
            // Start performance metrics updates
            updatePerformanceMetrics();
            setInterval(updatePerformanceMetrics, 5000); // Update every 5 seconds
            
            function initializeAltitudeChart() {
                const layout = {
                    title: 'Multi-Sensor Altitude Comparison',
                    xaxis: { title: 'Time' },
                    yaxis: { title: 'Altitude (m)' },
                    showlegend: true,
                    margin: { l: 50, r: 20, b: 50, t: 50 }
                };
                
                const traces = [
                    { x: [], y: [], mode: 'lines', name: 'Ground Truth', line: { color: SENSOR_COLORS.ground_truth, width: 3 } },
                    { x: [], y: [], mode: 'lines+markers', name: 'ALVIRA', line: { color: SENSOR_COLORS.alvira }, marker: { size: 4 } },
                    { x: [], y: [], mode: 'lines+markers', name: 'ARCUS', line: { color: SENSOR_COLORS.arcus }, marker: { size: 4 } },
                    { x: [], y: [], mode: 'markers', name: 'Current Position', marker: { size: 12, color: '#e74c3c' } }
                ];
                
                Plotly.newPlot('altitudeChart', traces, layout);
            }
            
            function initializeErrorChart() {
                const layout = {
                    title: 'Position Error Analysis',
                    xaxis: { title: 'Time' },
                    yaxis: { title: 'Position Error (m)' },
                    showlegend: true,
                    margin: { l: 50, r: 20, b: 50, t: 50 }
                };
                
                const traces = [
                    { x: [], y: [], mode: 'lines+markers', name: 'ALVIRA Error', line: { color: SENSOR_COLORS.alvira }, marker: { size: 4 } },
                    { x: [], y: [], mode: 'lines+markers', name: 'ARCUS Error', line: { color: SENSOR_COLORS.arcus }, marker: { size: 4 } }
                ];
                
                Plotly.newPlot('errorChart', traces, layout);
            }
            
            function initializeFlightPathMap() {
                const layout = {
                    title: 'Multi-Sensor Flight Path Comparison',
                    mapbox: {
                        style: 'open-street-map',
                        center: { 
                            lat: ({{ min_latitude }} + {{ max_latitude }}) / 2, 
                            lon: ({{ min_longitude }} + {{ max_longitude }}) / 2 
                        },
                        zoom: 16
                    },
                    margin: { l: 0, r: 0, b: 0, t: 50 },
                    showlegend: true
                };
                
                const traces = [
                    { type: 'scattermapbox', lon: [], lat: [], mode: 'lines', name: 'Ground Truth', line: { color: SENSOR_COLORS.ground_truth, width: 4 } },
                    { type: 'scattermapbox', lon: [], lat: [], mode: 'lines+markers', name: 'ALVIRA', line: { color: SENSOR_COLORS.alvira }, marker: { size: 6 } },
                    { type: 'scattermapbox', lon: [], lat: [], mode: 'lines+markers', name: 'ARCUS', line: { color: SENSOR_COLORS.arcus }, marker: { size: 6 } },
                    { type: 'scattermapbox', lon: [], lat: [], mode: 'markers', name: 'Current Position', marker: { size: 15, color: '#e74c3c' } }
                ];
                
                Plotly.newPlot('flightPathMap', traces, layout);
            }
            // Filter Sensor out
            function getSelectedSensors() {
                const checkboxes = document.querySelectorAll('#sensorFilter input[type="checkbox"]');
                const selected = Array.from(checkboxes)
                    .filter(cb => cb.checked)
                    .map(cb => cb.value);
                if (selected.includes("ALL")) {
                    return ["alvira", "arcus", "diana", "venus"];
                }

                return selected;
            }

      
            function updatePlots(index) {
                if (index >= droneData.length || index < 0) return;
                
                const currentPoint = droneData[index];
                const currentTime = new Date(currentPoint['datetime(utc)']).toLocaleTimeString();
                
                // Update time display
                currentTimeDisplay.textContent = `Time: ${currentTime}`;
                
                // Get data up to current point
                const dataSlice = droneData.slice(0, index + 1);
                
                // Prepare data arrays
                const times = dataSlice.map(d => d['datetime(utc)']);
                const gtAltitudes = dataSlice.map(d => d.gt_altitude);
                const gtLongitudes = dataSlice.map(d => d.gt_longitude);
                const gtLatitudes = dataSlice.map(d => d.gt_latitude);
                
                // Sensor data arrays
                const alviraAltitudes = dataSlice.map(d => d.alvira_altitude);
                const alviraLongitudes = dataSlice.map(d => d.alvira_longitude);
                const alviraLatitudes = dataSlice.map(d => d.alvira_latitude);
                const alviraErrors = dataSlice.map(d => d.alvira_pos_error_m);
                
                const arcusAltitudes = dataSlice.map(d => d.arcus_altitude);
                const arcusLongitudes = dataSlice.map(d => d.arcus_longitude);
                const arcusLatitudes = dataSlice.map(d => d.arcus_latitude);
                const arcusErrors = dataSlice.map(d => d.arcus_pos_error_m);
                
                // Manan's Old Code
                // Plotly.restyle('altitudeChart', {
                //    x: [times, times, times, [currentPoint['datetime(utc)']]],
                //    y: [gtAltitudes, alviraAltitudes, arcusAltitudes, [currentPoint.gt_altitude]]
                //}, [0, 1, 2, 3]);
                
                // Drop Down Code
                const selected = getSelectedSensors();
                const showAlt = selected.includes("alvira") || selected.includes("arcus");
                const showMap = selected.includes("alvira") || selected.includes("arcus");

                Plotly.restyle('altitudeChart', {
                    x: [
                        showAlt ? times : [null],  // ground truth
                        selected.includes("alvira") ? times : [null],
                        selected.includes("arcus") ? times : [null],
                        showAlt ? [currentPoint['datetime(utc)']] : [null]
                    ],
                    y: [
                        showAlt ? gtAltitudes : [null],
                        selected.includes("alvira") ? alviraAltitudes : [null],
                        selected.includes("arcus") ? arcusAltitudes : [null],
                        showAlt ? [currentPoint.gt_altitude] : [null]
                    ]
                }, [0, 1, 2, 3]);

                // Update error chart
                //Plotly.restyle('errorChart', {
                //    x: [times, times],
                //    y: [alviraErrors, arcusErrors]
                //}, [0, 1]); 

                Plotly.restyle('errorChart', {
                    x: [
                        selected.includes("alvira") ? times : [null],
                        selected.includes("arcus") ? times : [null]
                    ],
                    y: [
                        selected.includes("alvira") ? alviraErrors : [null],
                        selected.includes("arcus") ? arcusErrors : [null]
                    ]
                }, [0, 1]);

                
                // Update flight path map  
                //Plotly.restyle('flightPathMap', {
                //    lon: [gtLongitudes, alviraLongitudes, arcusLongitudes, [currentPoint.gt_longitude]],
                //    lat: [gtLatitudes, alviraLatitudes, arcusLatitudes, [currentPoint.gt_latitude]]
                //}, [0, 1, 2, 3]);
                
                // Update sensor status
                //updateSensorStatus(currentPoint);
                //}
            
            Plotly.restyle('flightPathMap', {
                lon: [
                    showMap ? gtLongitudes : [null],
                    selected.includes("alvira") ? alviraLongitudes : [null],
                    selected.includes("arcus") ? arcusLongitudes : [null],
                    showMap ? [currentPoint.gt_longitude] : [null]
                ],
                lat: [
                    showMap ? gtLatitudes : [null],
                    selected.includes("alvira") ? alviraLatitudes : [null],
                    selected.includes("arcus") ? arcusLatitudes : [null],
                    showMap ? [currentPoint.gt_latitude] : [null]
                ]
            }, [0, 1, 2, 3]);

            updateSensorStatus(currentPoint);}

            function updateSensorStatus(currentPoint) {
                // ALVIRA status
                const alviraStatus = document.getElementById('alviraStatus');
                if (currentPoint.alvira_latitude && !isNaN(currentPoint.alvira_latitude)) {
                    alviraStatus.textContent = `Active - Error: ${currentPoint.alvira_pos_error_m ? currentPoint.alvira_pos_error_m.toFixed(1) : 'N/A'}m`;
                    alviraStatus.style.color = '#2ecc71';
                } else {
                    alviraStatus.textContent = 'No Detection';
                    alviraStatus.style.color = '#e74c3c';
                }
                
                // ARCUS status
                const arcusStatus = document.getElementById('arcusStatus');
                if (currentPoint.arcus_latitude && !isNaN(currentPoint.arcus_latitude)) {
                    arcusStatus.textContent = `Active - Error: ${currentPoint.arcus_pos_error_m ? currentPoint.arcus_pos_error_m.toFixed(1) : 'N/A'}m`;
                    arcusStatus.style.color = '#2ecc71';
                } else {
                    arcusStatus.textContent = 'No Detection';
                    arcusStatus.style.color = '#e74c3c';
                }
                
                // DIANA status
                const dianaStatus = document.getElementById('dianaStatus');
                if (currentPoint.diana_bearing && !isNaN(currentPoint.diana_bearing)) {
                    dianaStatus.textContent = `Active - SNR: ${currentPoint.diana_snr ? currentPoint.diana_snr.toFixed(1) : 'N/A'}dB`;
                    dianaStatus.style.color = '#2ecc71';
                } else {
                    dianaStatus.textContent = 'No Signal';
                    dianaStatus.style.color = '#e74c3c';
                }
                
                // VENUS status
                const venusStatus = document.getElementById('venusStatus');
                if (currentPoint.venus_frequency && !isNaN(currentPoint.venus_frequency)) {
                    venusStatus.textContent = `Active - ${(currentPoint.venus_frequency / 1e6).toFixed(0)}MHz`;
                    venusStatus.style.color = '#2ecc71';
                } else {
                    venusStatus.textContent = 'No Signal';
                    venusStatus.style.color = '#e74c3c';
                }
            }
            
            function updatePerformanceMetrics() {
                fetch('/api/performance_metrics')
                    .then(response => response.json())
                    .then(data => {
                        const metricsGrid = document.getElementById('metricsGrid');
                        metricsGrid.innerHTML = '';
                        
                        // Helper function to determine metric card class
                        function getMetricClass(value, thresholds) {
                            if (value >= thresholds.good) return 'metric-card';
                            if (value >= thresholds.warning) return 'metric-card warning';
                            return 'metric-card error';
                        }
                        
                        // ALVIRA metrics
                        if (data.alvira) {
                            const detectionClass = getMetricClass(data.alvira.detection_rate, {good: 70, warning: 40});
                            const errorClass = data.alvira.mean_pos_error < 30 ? 'metric-card' : 
                                            data.alvira.mean_pos_error < 60 ? 'metric-card warning' : 'metric-card error';
                            
                            metricsGrid.innerHTML += `
                                <div class="${detectionClass}">
                                    <div class="metric-value">${data.alvira.detection_rate.toFixed(1)}%</div>
                                    <div class="metric-label">ALVIRA Detection Rate</div>
                                </div>
                                <div class="${errorClass}">
                                    <div class="metric-value">${data.alvira.mean_pos_error.toFixed(1)}m</div>
                                    <div class="metric-label">ALVIRA Avg Position Error</div>
                                </div>
                            `;
                        }
                        
                        // ARCUS metrics
                        if (data.arcus) {
                            const detectionClass = getMetricClass(data.arcus.detection_rate, {good: 70, warning: 40});
                            const errorClass = data.arcus.mean_pos_error < 30 ? 'metric-card' : 
                                            data.arcus.mean_pos_error < 60 ? 'metric-card warning' : 'metric-card error';
                            
                            metricsGrid.innerHTML += `
                                <div class="${detectionClass}">
                                    <div class="metric-value">${data.arcus.detection_rate.toFixed(1)}%</div>
                                    <div class="metric-label">ARCUS Detection Rate</div>
                                </div>
                                <div class="${errorClass}">
                                    <div class="metric-value">${data.arcus.mean_pos_error.toFixed(1)}m</div>
                                    <div class="metric-label">ARCUS Avg Position Error</div>
                                </div>
                            `;
                        }
                        
                        // DIANA metrics
                        if (data.diana) {
                            const detectionClass = getMetricClass(data.diana.detection_rate, {good: 50, warning: 25});
                            const snrClass = data.diana.mean_snr > -70 ? 'metric-card' : 'metric-card warning';
                            
                            metricsGrid.innerHTML += `
                                <div class="${detectionClass}">
                                    <div class="metric-value">${data.diana.detection_rate.toFixed(1)}%</div>
                                    <div class="metric-label">DIANA Detection Rate</div>
                                </div>
                                <div class="${snrClass}">
                                    <div class="metric-value">${data.diana.mean_snr.toFixed(1)}dB</div>
                                    <div class="metric-label">DIANA Avg SNR</div>
                                </div>
                            `;
                        }
                        
                        // VENUS metrics
                        if (data.venus) {
                            const detectionClass = getMetricClass(data.venus.detection_rate, {good: 50, warning: 25});
                            
                            metricsGrid.innerHTML += `
                                <div class="${detectionClass}">
                                    <div class="metric-value">${data.venus.detection_rate.toFixed(1)}%</div>
                                    <div class="metric-label">VENUS Detection Rate</div>
                                </div>
                                <div class="metric-card">
                                    <div class="metric-value">${(data.venus.mean_frequency / 1e6).toFixed(0)}MHz</div>
                                    <div class="metric-label">VENUS Avg Frequency</div>
                                </div>
                            `;
                        }
                        
                        // Overall system status
                        const totalSensors = Object.keys(data).length;
                        metricsGrid.innerHTML += `
                            <div class="metric-card">
                                <div class="metric-value">${totalSensors}</div>
                                <div class="metric-label">Active Sensors</div>
                            </div>
                        `;
                    })
                    .catch(error => {
                        console.error('Error fetching metrics:', error);
                        document.getElementById('metricsGrid').innerHTML = `
                            <div class="metric-card error">
                                <div class="metric-value">Error</div>
                                <div class="metric-label">Loading Metrics</div>
                            </div>
                        `;
                    });
            }
            
            // Event listeners
            timeSlider.addEventListener('input', (event) => {
                const selectedIndex = parseInt(event.target.value);
                updatePlots(selectedIndex);
            });

            //check box
            const allCheckbox = document.querySelector('#sensorFilter input[value="ALL"]');
            const individualCheckboxes = Array.from(document.querySelectorAll('#sensorFilter input:not([value="ALL"])'));

            document.querySelectorAll('#sensorFilter input').forEach(cb => {
                cb.addEventListener('change', () => {
                    const selected = individualCheckboxes.filter(c => c.checked);

                    if (cb.value === "ALL") {
                        if (cb.checked) {
                            individualCheckboxes.forEach(c => c.checked = true);
                        }
                    } else {
                        allCheckbox.checked = selected.length === individualCheckboxes.length;
                    }

                    // Refresh current view
                    updatePlots(parseInt(timeSlider.value));
                });
            });

            
            // Keyboard controls for better navigation
            document.addEventListener('keydown', (event) => {
                let currentIndex = parseInt(timeSlider.value);
                
                switch(event.key) {
                    case 'ArrowLeft':
                        if (currentIndex > 0) {
                            timeSlider.value = currentIndex - 1;
                            updatePlots(currentIndex - 1);
                        }
                        break;
                    case 'ArrowRight':
                        if (currentIndex < droneData.length - 1) {
                            timeSlider.value = currentIndex + 1;
                            updatePlots(currentIndex + 1);
                        }
                        break;
                    case 'Home':
                        timeSlider.value = 0;
                        updatePlots(0);
                        break;
                    case 'End':
                        timeSlider.value = droneData.length - 1;
                        updatePlots(droneData.length - 1);
                        break;
                }
            });
            
            // Initialize with first data point.
            if (droneData.length > 0) {
                updatePlots(0);
                console.log(`Dashboard initialized with ${droneData.length} data points`);
            } else {
                console.error('No data available for dashboard');
            }
        </script>
    </div>

<div id="walkthroughModal" style="display: none; position: fixed; z-index: 9999; left: 0; top: 0; width: 100vw; height: 100vh; background-color: rgba(0,0,0,0.6);">
    <div style="background: white; border-radius: 10px; max-width: 800px; margin: 10% auto; padding: 30px; position: relative; box-shadow: 0 10px 40px rgba(0,0,0,0.3);">
        <h2 style="margin-top: 0; color: #2c3e50;">üìò How to Use This Dashboard</h2>
        <ul style="line-height: 1.6; font-size: 1em; padding-left: 20px; color: #333;">
            <li><strong>Use the Timeline Slider</strong> to move through the mission in time. You can also use your keyboard:
                <ul style="margin-top: 5px; padding-left: 20px; list-style-type: circle;">
                    <li><kbd>‚Üê</kbd> / <kbd>‚Üí</kbd> to step through frames</li>
                    <li><kbd>Home</kbd> to jump to the beginning</li>
                    <li><kbd>End</kbd> to jump to the end</li>
                </ul>
            </li>
            <li>The <strong>Altitude Chart</strong> shows drone altitude from sensors vs ground-truth.</li>
            <li>The <strong>Error Chart</strong> displays position error (in meters) over time.</li>
            <li>The <strong>Flight Path Map</strong> maps all positions using real geolocation data.</li>
            <li><strong>Sensor Cards</strong> indicate real-time status per detection system.</li>
            <li><strong>Performance Metrics</strong> update every 5 seconds with sensor performance.</li>
        </ul>
        <p style="margin-top: 20px; font-size: 0.95em; color: #666;"><em>This dashboard dynamically visualizes multi-sensor fusion. Data updates in real time as you scrub through the timeline.</em></p>
        
        <button onclick="closeModal()" style="position: absolute; top: 15px; right: 15px; font-size: 1.2em; background: none; border: none; color: #666; cursor: pointer;">‚úñÔ∏è</button>
    </div>
</div>
<script>
    function openModal() {
        document.getElementById('walkthroughModal').style.display = 'block';
    }
    function closeModal() {
        document.getElementById('walkthroughModal').style.display = 'none';
    }
</script>

</body>
</html>